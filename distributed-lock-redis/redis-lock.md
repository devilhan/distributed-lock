#H1 解决哈希冲突方法：
    拉链法
    开发地址法
    再哈希

#H1 三种分布式模式
    主从
    哨兵
    集群

#H1分布式锁 
    # 基于redis的setnx实现分布式锁
        情况1： 如果锁没执行到释放，比如业务逻辑执行一半，运维重启服务，或服务器挂了，没走finally ，怎么办？
                加超时时间
        情况二：加超时时间,会有加不上的情况，运维重启
        情况三：超时时间应该一次加，不应该分2行代码
        释放锁：避免释放其他人的锁，将标识值放在value中
    # redission实现分布式锁
        redis故障问题。
            如果redis故障了，所有客户端无法获取锁，服务变得不可用。为了提高可用性。我们给redis 配置主从。当master不可用时，系统切换到slave，由于Redis的主从复制（replication）是异步的，这可能导致丧失锁的安全性
            
            1.客户端1从Master获取了锁。
            2.Master宕机了，存储锁的key还没有来得及同步到Slave上。
            3.Slave升级为Master。
            4.客户端2从新的Master获取到了对应同一个资源的锁。
            
            客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。
            
            锁的有效时间(lock validity time)，设置成多少合适？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。应该设置稍微短一些，如果线程持有锁，开启线程自动延长有效期
                # 使用red Lock 实现分布式锁
     