#H1 mysql 锁详解

共享锁（S锁）Shared Locks
    1、兼容性：加了S锁的记录，允许其他事务再加S锁，不允许其他事务
    2、加锁方式：select…lock in share mode

排他锁（X锁）Exclusive Locks
    1、兼容性：加了X锁的记录，不允许其他事务再加S锁或者X锁
    2、加锁方式：select…for update

表锁 意向锁 相互兼容 Intention Locks
    1、表明“某个事务正在某些行持有了锁、或该事务准备去持有锁”
    2、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存
    3、例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。

    意向共享锁（IS锁）：事务在请求S锁前，要先获得IS锁
    意向排他锁（IX锁）：事务在请求X锁前，要先获得IX锁

    Q1：为什么意向锁锁表级锁？
        当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；
        （1）如果意向锁是行锁，则需要遍历每一行数据去确认；
        （2）如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。

    Q2：意向锁怎么支持表锁和行锁并存？
        （1）首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。
        （2）如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。
    
    意向锁，共享锁，排他锁兼容关系：
                
        是否兼容    事务A IS     IX      S       X
        事务B IS         是     是      是      否
        IX              是     是      否      否 
        S               是     否      是      否
        X               否     否      否      否

    意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。
    因为上了表级S锁后，不允许其他事务再加X锁，所以表级S锁和X、IX锁不兼容
    上了表级X锁后，会修改数据，所以表级X锁和 IS、IX、S、X（即使是行排他锁，因为表级锁定的行肯定包括行级速订的行，所以表级X和IX、行级X）不兼容。
    注意：上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行。

行锁：
    记录锁（Record Locks）
        （1）记录锁, 仅仅锁住索引记录的一行，在单条索引记录上加锁。
        （2）record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。
            所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。
    间隙锁（Gap Locks）
        （1）区间锁, 仅仅锁住一个索引区间（开区间，不包括双端端点）。
        （2）在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。
            比如在 1、2、3中，间隙锁的可能值有 (∞, 1)，(1, 2)，(2, ∞)，
        （3）间隙锁可用于防止幻读，保证索引间的不会被插入数据
    临键锁（Next-key Locks）
        （1）record lock + gap lock, 左开右闭区间。
        （2）默认情况下，innodb使用next-key locks来锁定记录。select … for update
        （3）但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
        （4）Next-Key Lock在不同的场景中会退化:
            场景                                              退化成的锁类型
            使用unique index精确匹配（=），且记录存在             Record Lock
            使用unique index精确匹配O（=），且记录不存在           Gap Lock
            使用unique index范围匹配（<和>）                     Record Lock+Gap Lock，锁上界，不锁下界

    mysql有七种日志文件：
        重做日志 redo log
        回滚日志 undo log
        二进制日志 binlog
        错误日志 error log
        慢查询日志 slow query log
        一般查询日志 general log
        中继日志 relay log
    

        binlog三种模式：ROW  STATEMENT  MIXED
 